#include <stdio.h>
#include <stdlib.h>
#include <gmp.h>

#define NUM_INPUT 100

#define MAX_FACTORS 512

#define MAX_NUMBER_OF_TRIES 1000000000 //190000 (with 300 (and with 900) trial division) //202000 // < 205 000

#define NUM_TRIAL_DIVIDES 1 //(NOTE must be >0)

#define NEXT_VALUE(r, x, n, c) \
    mpz_mul(r, x, x);          \
    mpz_add(r, r, c);          \
    mpz_mod(r, r, n)

#define IS_ONE(x)  mpz_cmp_ui(x, 1)
#define IS_PRIME(x) mpz_probab_prime_p(x, 10)
#define FAILED(x) mpz_cmp_ui(x, 0) == 0
#define ADD_FACTOR(factors, num_factors, factor) \
    do {                                         \
        mpz_set( factors[num_factors], factor);  \
        num_factors++;                           \
    } while (0)


#include "primes.h" //static int prime_list [] = {2,3,7,11,....};

static gmp_randstate_t randstate;
static mpz_t ZERO;

static void pollard_brent(mpz_t d, mpz_t n, mpz_t init, int counter)
{
    mpz_t x, y, neg;

    mpz_init(neg);
    mpz_init_set_ui(x,  2);
    mpz_init_set(y, x);
    mpz_set_ui(d, 1);
    while (mpz_cmp_ui(d, 1) == 0) {

        mpz_mul(x, x, x);
        mpz_add_ui(x, x, 3);
        mpz_mod(x, x, n);
        
        mpz_sub_ui(neg, x, 1);
        mpz_and(neg, x, neg);
        if(mpz_cmp_ui(neg, 0) == 0) {
            mpz_set(y, x);
        }

        mpz_sub(d, x, y);
        mpz_abs(d, d);
        mpz_gcd(d, d, n);


        if (counter < 0){
            mpz_set_ui(d,0);
            return;
        } else {
            --counter;
        }
    }

    if(mpz_cmp(d, n) == 0) {
        mpz_urandomm(init, randstate, n);
        return pollard_brent(d, n, init, counter);
    }

}

static void pollard(mpz_t d, mpz_t n, mpz_t init, mpz_t c, int counter)
{
    mpz_t x_1, x_2;

    mpz_init(x_1);
    mpz_init(x_2);

    mpz_set(x_1, init);
    NEXT_VALUE(x_1, x_1, n, c);
    NEXT_VALUE(x_2, x_1, n, c);

    mpz_sub(d, x_2, x_1);
    mpz_gcd(d, d, n);
    while (mpz_cmp_ui(d, 1) == 0) {
        NEXT_VALUE(x_1, x_1, n, c);
        NEXT_VALUE(x_2, x_2, n, c);
        NEXT_VALUE(x_2, x_2, n, c);
        mpz_sub(d, x_2, x_1);
        mpz_abs(d, d);
        mpz_gcd(d, d, n);
    
        if (counter < 0){
            mpz_set_ui(d,0);
            return;
        } else {
            --counter;
        }
    }

    mpz_clear(x_1);
    mpz_clear(x_2);

    if(mpz_cmp(d, n) == 0) {
        mpz_urandomm(init, randstate, n);
        mpz_urandomm(c, randstate, n);
        return pollard(d, n, init, c, counter);
    }
}

static int trial_divide(mpz_t n, mpz_t *factors, int *num_factors, 
                        int should_factor) 
{
    int i;
    int new_factors = *num_factors;
    for (i = 0; i < NUM_TRIAL_DIVIDES; ++i) {
        while(mpz_divisible_ui_p(n, primes[i])) {
            if(should_factor) {
                mpz_set_ui(factors[new_factors], primes[i]);
                new_factors++;
            }
            mpz_divexact_ui(n, n, primes[i]);
        }
    }
    if (new_factors > *num_factors) {
        if(should_factor) {
            *num_factors = new_factors;
        }
        return 1;
    }
    return 0;
} 

static unsigned long log_2_ceil(mpz_t n)
{
    mpz_t q;
    unsigned long res = 0;
    mpz_init_set(q, n);

    while(mpz_cmp_ui(q, 1) != 0) { 
        mpz_cdiv_q_2exp(q, q, 1);
        ++res;
    }

    return res;
}

static int nth_root(mpz_t rop, mpz_t op, unsigned long n)
{
    return mpz_root(rop, op, n);
}

static int factor(mpz_t n, mpz_t *factors);

static int factor_perfect_prime(mpz_t n, mpz_t *factors, int num_factors,
                                 int should_factor)
{
    mpz_t a;
    unsigned long max_b = log_2_ceil(n);
    unsigned long b;
    mpz_init(a);
    for(b = max_b; b >= 2; --b) {
        if(nth_root(a, n, b) != 0) {
            if(should_factor) {
                int new_factors = factor(a, factors + num_factors);
                unsigned long i;
                for (i = 0; i < b; ++i) {
                    int j;
                    for (j = 0; j < new_factors; ++j) {
                        mpz_set(factors[num_factors + new_factors + i*j],
                                factors[num_factors + i*j]);

                    }
                }
                return num_factors + new_factors * i;
            }
            mpz_set(n, a);
            break;
        }
    }
    mpz_clear(a);
    return 0;
}

static int factor(mpz_t n, mpz_t *factors)
{
    mpz_t d, tmp;
    int num_factors = 0;
    mpz_init(d);
    mpz_init(tmp);

    while (IS_ONE(n) != 0 && IS_PRIME(n) == 0) {
        if(mpz_perfect_power_p(n)) {
            return factor_perfect_prime(n, factors, num_factors, 1);
        }

        if(trial_divide(n, factors, &num_factors, 1)) {
            continue;
        }

        pollard(d, n, ZERO, ZERO, MAX_NUMBER_OF_TRIES);
        //pollard_brent(d, n, ZERO, MAX_NUMBER_OF_TRIES);

        if(FAILED(d)) {
            return 0;
        }

        while (IS_ONE(d) != 0 && IS_PRIME(d) == 0) {
            if(mpz_perfect_power_p(d)) {
                factor_perfect_prime(d, factors, num_factors, 0);
                break;
            }

            if(trial_divide(d, factors, &num_factors, 0)) {
                continue;
            }

            pollard(tmp, d, ZERO, ZERO, MAX_NUMBER_OF_TRIES);
            //pollard_brent(tmp, d, ZERO, MAX_NUMBER_OF_TRIES);

            if(FAILED(tmp)) {
                return 0;
            }

            mpz_set(d, tmp);
        }
        do {
            ADD_FACTOR(factors, num_factors, d);
            mpz_divexact(n, n, d);
        } while (mpz_divisible_p(n, d));
    }
    if(IS_ONE(n) != 0) {
        ADD_FACTOR(factors, num_factors, n);
    }
    return num_factors;
}

static void print_factors(mpz_t *factors, int num_factors)
{
    int i;

    if (num_factors == 0) {
        printf("fail\n");
    } else {
        for (i = 0; i < num_factors; ++i) {
            gmp_printf("%Zd\n", factors[i]);
        }
    }
    putchar('\n');
}


int main(void)
{
    int i, num_factors;
    mpz_t n;
    mpz_init(n); //mpz_init_set_ui
    mpz_init_set_ui(ZERO, 0);
    gmp_randinit_default(randstate);

    mpz_t *factors = malloc(sizeof(mpz_t) * MAX_FACTORS);

    for(i = 0; i < MAX_FACTORS; ++i) {
        mpz_init(factors[i]);
    }

    for (i = 0; i < NUM_INPUT; ++i) {
        mpz_inp_str(n, stdin, 10);
        num_factors = factor(n, factors);
        print_factors(factors, num_factors);
    }

    return 0;
}
