%\documentclass[a4paper]{article}
\documentclass[a4paper,twoside=false,abstract=false,numbers=noenddot,
titlepage=false,headings=small,parskip=half,version=last]{scrartcl}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{multirow}
\usepackage{verbatim}
\usepackage[colorlinks=true,pdfstartview=FitV,linkcolor=black, citecolor=black,urlcolor=blue]{hyperref}
\usepackage[T1]{fontenc}	      
\usepackage[swedish]{babel}
\usepackage[utf8]{inputenc}


\DeclareMathOperator*{\argmax}{arg\,max}

\author{Jim Holmström F-08 890503-7571}
\title{DD2440 Advanced Algorithms}
\subtitle{Homework A}

\begin{document}
\maketitle

\section{Problem 1}

\begin{equation} \label{eq:gcddomain}
    \text{Given: }    a,b \ge 0 \wedge \neg(a=b=0)
\end{equation}

\begin{equation} \label{eq:gcddefinition}
   \text{Definition of gcd: } \gcd(a,b)=c \iff \argmax_c \{c|a \wedge c|b\}
\end{equation}

\subsection{Validate}

In order from the top.

\begin{equation} \label{eq:statement1}
    \verb+if (b > a) return gcd(b, a)+
\end{equation}
Sorts the arguments resulting in $: a \ge b$ and trivially holds from (\ref{eq:gcddefinition}) with $a \leftrightarrow b$ and using the commutative property of ``$\wedge$''

\begin{equation} \label{eq:statement2}
    \verb+else if (b == 0) return a+
\end{equation}
Acts as base case. $i \neq 0$ from (\ref{eq:gcddomain}) $\gcd(i,0)=i$ since $c=i$ is the largest $c : (c|i \wedge c|0)$

\begin{equation} \label{eq:statement3}
    \verb+else if (a and b are even) return 2*gcd(a/2, b/2)+ 
\end{equation}
Since both a and b are even both must have at least the factor 2 in common.
More generally:
\begin{equation}
    \gcd(pm,pn)=p\cdot \gcd(m,n)
\end{equation}
In our case $a=2m$ and $b=2n$

\begin{equation} \label{eq:statement4}
    \verb+else if (a is even) return gcd(a/2, b)+
\end{equation}
Since we now that we have passed the above statement we have that $b$ is odd thus $2$ cannot be a factor, and we can thus remove the factor $2$ from $a$ without influencing the result.

\begin{equation} \label{eq:statement5}
    \verb+else if (b is even) return gcd(a, b/2)+
\end{equation}
The same way as above but $a \leftrightarrow b$

\begin{equation*} \label{eq:statement6}
    \verb+else return gcd(b,a-b)+
\end{equation*}
(\ref{eq:statement1}) $\Rightarrow a-b \ge 0$ and (\ref{eq:statement2}) $\Rightarrow b \neq 0$ and thus the parameters will at least be within the domain. \\

$
    \gcd(b,a-b)=\argmax_c \{b|c \wedge (a-b)|c\}=\\
    \{ (a-\underbrace{b}_{b|c})|c \Rightarrow
    \{ \text{$a$ must have a factor $c$}, c(a/c+b/c)|c \} \Rightarrow
    a|c \}\\
    =\argmax_x\{a|c \wedge b|c\}=\gcd(a,b)
$
and thus the statement holds. \\

All the recursive calls holds, has arguments within the domain, the argumentsum is strictly smaller for all calls (except (\ref{eq:statement1}) but it can only be called once in a row) $\Rightarrow$ will always land in the basecase (\ref{eq:statement2}) and return the correct $\gcd$. $\qed$

\subsection{Number of recursive calls}

gcd(b,a-b*(a/b)) simple wurst case will then be a/b
in (b,(a-b)): (oe: a=odd,b=even)
    oo: (o,o-o)=>(o,e) ONLY CASE!
    { can't occure!! 
       oe: (e,o-e)=>(e,o) (already taken care of by b-even-statement)
       eo: (o,e-o)=>(e,o) (already taken care of by a-even-statement)
       ee: (e,e-e)=>(e,e) (already taken care of by both-even-statement)
    }

slutsats: the calls will be alternating b-even-statement and the laststatement, depth of that one? the b-evenstatement halvs the size of the size of b, ??? how will this effect? will it converge slower since the smallest number is halved?


\subsection{Bit complexity}

operation-cost
a/2 = O(n)/O(1) ?
a-b = a-b naive bitcomplexity O(loga+logb)


\section{Problem 2}
\begin{equation*}
    N=8905037571, \\
    a_{1}=123456789, \\
    a_{2}=987654321
\end{equation*}

???linear diophantine equation au+bv=gcd(u,v) and hence compute the multip-inverses (mod u)
CHECK IT OUT: http://www.msri.org/realvideo/ln/msri/2000/introant/shallit/1/banner/08.html

Simple relations used: 
\begin{equation} \label{eq:gcdplusone}
    c \ge 0 \Rightarrow  \gcd(c+1,c)=1
\end{equation}
\begin{equation} \label{eq:modrule}
    c\cdot d+a \equiv a\ (mod\ d) 
\end{equation}

\begin{equation} \label{eq:congruenceproblem}
    \text{Find a positive } x < N(N+1) : 
    \begin{cases}
        x \equiv a_{1}\ (mod\ N)\\
        x \equiv a_{2}\ (mod\ N+1)
    \end{cases}
\end{equation}

Put$x$ as a smart linear combination of $a_{1:2}$. 
$x=a_{1}b_{1}(N+1)+a_{2}b_{2}N$

\begin{equation} \label{eq:bigstep}
    \begin{cases}
        x \equiv a_{1}b_{1}(N+1)+a_{2}b_{2}N\ \equiv \{(\ref{eq:modrule})\} \equiv a_{1}b_{1}(N+1)\ (mod\ N)\\
        x \equiv a_{1}b_{1}(N+1)+a_{2}b_{2}N\ \equiv \{(\ref{eq:modrule})\} \equiv a_{2}b_{2}N\ (mod\ N+1)
    \end{cases}
\end{equation}

(\ref{eq:congruenceproblem}) and (\ref{eq:bigstep}) gives:

\begin{equation} \label{eq:congruencecombination}
    \begin{cases}
        a_{1}b_{1}(N+1) \equiv a_{1}\ (mod\ N)\\
        a_{2}b_{2}N \equiv a_{2}\ (mod\ N+1)
    \end{cases}
    \Rightarrow
    \begin{cases}
        b_{1}(N+1) \equiv 1\ (mod\ N)\\
        b_{2}N \equiv 1\ (mod\ N+1)
    \end{cases}
\ %ugly fix for some bug
\end{equation}

$x$ satisfies (\ref{eq:congruenceproblem}) if $b_{1:2}$ satisfies (\ref{eq:congruencecombination})
\begin{equation*}
    b_{1}(N+1) \equiv b_{1}N+b_{1} \equiv \{(\ref{eq:modrule})\} \equiv b_{1} \equiv 1\ (mod\ N) 
\end{equation*}
\begin{equation*}
    b_{2}N \equiv b_{2}(N+1)-b_{2} \equiv \{(\ref{eq:modrule})\} \equiv -b_{2} \equiv 1\ (mod\ N+1)
    \Rightarrow
    b_{2} \equiv 1\cdot (-1) \equiv N\ (mod\ N+1)
\end{equation*}

\begin{equation*}
    \begin{split}
        \therefore x & \equiv a_{1}(N+1)+a_{2}N^{2} \equiv \{\text{(using pythons native big-integer support)}\} \equiv \\
        & \equiv \underline{71603982658724599629}\ (mod\ N(N+1))
    \end{split}
\end{equation*}

The $x$ found solves (\ref{eq:congruenceproblem}) and $x<N(N+1) \qed$


\section{Problem 3}

!!! Note this has a unitcost RAM so you must check that it doesn't address more then $2^w$ amounth of RAM

From Fabios:\\

To achieve the linear time bound we use a radix sort that sorts using $\lceil{\log_2(N+1)}\rceil$ bits at a time 
(since we know that if $m = O(n^k)$,$m$ consists of $O(k\cdot log_2{n})$ number of bits.
When sorting $\lceil\log_2{(n+1)}\rceil$ bits at a time the largest number that occurs is $O(n)$, 
and we know that the number of elements is $n$.
Then by the prevoius question we can do this sorting step in $O(n)$ time. We then proceed to sort the next $\lceil\log_2{(n+1)}\rceil$ bits, and
repeat this $O(k)$ times.\\
Thus sorting the whole list takes $O(kn)$ time, though $k$ is just some constant so we claim that the whole sorting algorigm take $O(n)$ time.

``The prevoius question''

sketchy:
1.create buckets (buckets contained in array and each bucket a linked list)
2.put each element in corresponding bucket O(n) since finding and putting in the linked list is in constant time
3.finally go tru the buckets and glue them 2 gethör

\section{Problem 4}


$1 < m \leq n$

sketchy:

NOTE one must make a hashmap or equal to get the putting in the right bucket O(1), compare bucketsort

1. put all input in their corresponding bucket $b_i$ (based on $elem=i$,i is the value of the input) where bucket is a linked list (adding and (...whut did fabios write?) $O(1)$) so this step is $O(n)$
2. heapsort the buckets based on their corresponding value $i$
3. Go thru all buckets and stitch them 2gethör $O(m)$

resulting ordo will be $ O(n) \vee O(mlogm)$ by testing the extreme $m=n$ and $m=2$ one can see that the resulting running time will be $O(nlogm)$ (explain more?)

$\qed$
\section{Problem 5}

!!!! use the term: expression \notin TAUT

Resolution Rule: $\frac{C \vee x \ \ \ \ \ \ D \vee \not x}{C \vee D}$ where C,D \in \bigvee{c_i} in our case i=1 because of 2CNF criteria 

sketchy:
0. go thru the input and generate the buckets 2m variables=> O(m)
1. generate clauses (pair of variables in arraylist) and put pointers to the varibles in the buckets (arraylists) $b_i$ or $b_i^(\not)$ (when putting in something in b_i also create b_i^not and viceverse)         O(n)
   "do while(4) #runs <= m  (since 2clauses is becoming 1clause) O(m)" 
2. DO WHILE: the clause is i v i = i (resulting in that i must be true not a TAUNT) return fail else i v C without any matching inverse return fail ELSE IF no clauses left return IS_TAUNT
    3. pick the first variable in the first clause lookup a matching inverse among the buckets (not being ) and pick the first one
    4. do resolution on these
    5. update the buckets <-important

!! draw the conclusion that its mosdef \in P

!!check again with the pointers etc. to show dat it really worsks !!


\end{document}
